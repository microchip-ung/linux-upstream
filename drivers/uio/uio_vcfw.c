/*
 * VCoreIII firmware buffer interface
 *
 * Copyright (C) 2016 Microsemi Inc.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation version 2.
 *
 * This program is distributed "as is" WITHOUT ANY WARRANTY of any
 * kind, whether express or implied; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#include <linux/device.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/platform_device.h>
#include <linux/uio_driver.h>
#include <linux/io.h>
#include <linux/slab.h>

#define DRV_NAME "vcfw_uio"
#define DRV_VERSION "1.0"

struct uio_vcfw_dev {
	struct uio_info *info;
	void __iomem *vcfwio_vaddr;
};

static void vcfw_cleanup(struct platform_device *dev,
                         struct uio_info *info)
{
	iounmap(info->mem[0].internal_addr);
	kfree(info);
}

static int vcfw_probe(struct platform_device *dev)
{
	struct uio_info *info;
	struct resource *regs_vcfwio;
	int ret = -ENODEV, len;

        dev_info(&dev->dev, "UIO driver loading\n");

	info = kzalloc(sizeof(struct uio_info), GFP_KERNEL);
	if (!info)
		return -ENOMEM;

	regs_vcfwio = platform_get_resource(dev, IORESOURCE_MEM, 0);
	if (!regs_vcfwio) {
                dev_info(&dev->dev, "No firmware I/O resource specified, not registering\n");
		goto out_free;
	}

	if (!regs_vcfwio->start) {
		dev_info(&dev->dev, "Null memory resource, not registering\n");
		goto out_free;
	}

        info->mem[0].addr = regs_vcfwio->start;
        info->mem[0].size = resource_size(regs_vcfwio);
        info->mem[0].memtype = UIO_MEM_PHYS;
	len = resource_size(regs_vcfwio);
	info->mem[0].internal_addr = ioremap(regs_vcfwio->start, len);
	if (!info->mem[0].internal_addr) {
		dev_err(&dev->dev, "Can't remap VCFW I/O address range\n");
		goto out_free;
	}

        info->name = DRV_NAME;
        info->version = DRV_VERSION;

        ret = uio_register_device(&dev->dev, info);
        if (ret < 0)
                goto out_free;

	platform_set_drvdata(dev, info);
	return 0;

out_free:
	vcfw_cleanup(dev, info);
	return ret;
}

static int vcfw_remove(struct platform_device *dev)
{
	struct uio_info *info = platform_get_drvdata(dev);

	vcfw_cleanup(dev, info);
	return 0;
}

static struct platform_driver vcfw_driver = {
	.probe = vcfw_probe,
	.remove = vcfw_remove,
	.driver = {
		   .name = DRV_NAME,
		   .owner = THIS_MODULE,
		   },
};

module_platform_driver(vcfw_driver);

MODULE_LICENSE("GPL v2");
MODULE_VERSION(DRV_VERSION);
MODULE_AUTHOR("Lars Povlsen <lars.povlsen@microsemi.com>");
